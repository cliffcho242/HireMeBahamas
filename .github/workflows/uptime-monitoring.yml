  # --------------------------
  # Render backend uptime monitoring
  # --------------------------
  uptime-monitoring:
    name: Render Backend Health Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      issues: write
    steps:
      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Check Render Backend Health
        id: check-render
        continue-on-error: true
        env:
          RENDER_BACKEND_URL: ${{ vars.RENDER_BACKEND_URL }}
        run: |
          if [ -z "$RENDER_BACKEND_URL" ]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi

          RESPONSE=$(curl -s -w "\n%{http_code}" --max-time 30 "$RENDER_BACKEND_URL/health" || true)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          if [ "$HTTP_CODE" = "200" ]; then
            DB_STATUS=$(echo "$BODY" | jq -r '.database.status // "unknown"' 2>/dev/null)
            case "$DB_STATUS" in
              healthy) echo "status=healthy" >> $GITHUB_OUTPUT ;;
              degraded) echo "status=degraded" >> $GITHUB_OUTPUT ;;
              *)        echo "status=partial" >> $GITHUB_OUTPUT ;;
            esac
          elif [ -n "$HTTP_CODE" ] && [ "$HTTP_CODE" != "000" ]; then
            echo "status=error" >> $GITHUB_OUTPUT
          else
            echo "status=down" >> $GITHUB_OUTPUT

      - name: Measure Render Backend Latency
        id: render-latency
        if: steps.check-render.outputs.status == 'healthy'
        env:
          RENDER_BACKEND_URL: ${{ vars.RENDER_BACKEND_URL }}
        run: |
          start=$(date +%s%N)
          curl -s --max-time 10 "$RENDER_BACKEND_URL/ping" > /dev/null || true
          end=$(date +%s%N)
          latency=$(( (end - start)/1000000 ))
          echo "latency_ms=$latency" >> $GITHUB_OUTPUT

      - name: Generate Uptime Summary
        id: summary
        run: |
          status="${{ steps.check-render.outputs.status }}"
          latency="${{ steps.render-latency.outputs.latency_ms }}"
          echo "## ðŸ“Š Render Backend Uptime Report" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status | Details |" >> $GITHUB_STEP_SUMMARY
          case "$status" in
            healthy) echo "| Render Backend | âœ… Healthy | Latency: ${latency:-N/A}ms |" >> $GITHUB_STEP_SUMMARY ;;
            degraded) echo "| Render Backend | âš ï¸ Degraded | Database issues detected |" >> $GITHUB_STEP_SUMMARY ;;
            partial) echo "| Render Backend | âš ï¸ Partial | Some components may have issues |" >> $GITHUB_STEP_SUMMARY ;;
            error) echo "| Render Backend | âŒ Error | HTTP error |" >> $GITHUB_STEP_SUMMARY ;;
            down) echo "| Render Backend | âŒ Down | Unreachable |" >> $GITHUB_STEP_SUMMARY ;;
            skipped) echo "| Render Backend | â­ï¸ Skipped | Not configured |" >> $GITHUB_STEP_SUMMARY ;;
          esac
          echo "overall_status=$status" >> $GITHUB_OUTPUT

      - name: Create Issue on Critical Failure
        if: steps.check-render.outputs.status == 'down'
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.check-render.outputs.status }}';
            if (status !== 'down') return;
            const existing = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'alert:downtime'
            });
            if (existing.data.length > 0) return;
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Render Backend Down`,
              body: `Render backend unreachable at ${new Date().toISOString()}`,
              labels: ['alert:downtime','priority:high']
            });
