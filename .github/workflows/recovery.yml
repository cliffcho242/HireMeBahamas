name: Workflow Failure Recovery

on:
  workflow_run:
    workflows: ["CI - Lint, Test, and Build"]
    types:
      - completed

jobs:
  analyze-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    permissions:
      actions: write
      contents: read
      issues: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Analyze Failure Pattern
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = context.payload.workflow_run.id;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Get workflow run jobs
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner,
              repo,
              run_id
            });
            
            let failurePatterns = [];
            let transientErrors = 0;
            let persistentErrors = 0;
            
            // Common transient error patterns
            const transientPatterns = [
              'connection timeout',
              'network error',
              'ETIMEDOUT',
              'ECONNRESET',
              'ENOTFOUND',
              'rate limit',
              'temporary failure',
              'failed to install',
              'npm ci',
              'pip install',
              'apt-get',
              '504 Gateway',
              '503 Service',
              'connection refused'
            ];
            
            for (const job of jobs.jobs) {
              if (job.conclusion === 'failure') {
                const logUrl = job.html_url;
                
                // For transient detection, we'd need to check actual logs
                // For now, use job name heuristics combined with common patterns
                const jobName = job.name.toLowerCase();
                
                // Check if job name suggests installation or network operations
                const isLikelyTransient = 
                  jobName.includes('install') ||
                  jobName.includes('setup') ||
                  jobName.includes('dependencies');
                
                if (isLikelyTransient) {
                  transientErrors++;
                } else {
                  persistentErrors++;
                }
                
                failurePatterns.push({
                  job: job.name,
                  conclusion: job.conclusion,
                  url: logUrl
                });
              }
            }
            
            const analysis = {
              total_failed: failurePatterns.length,
              transient_likely: transientErrors,
              persistent_likely: persistentErrors,
              patterns: failurePatterns
            };
            
            core.setOutput('analysis', JSON.stringify(analysis));
            // Only retry if transient errors are more than persistent AND total failures are reasonable
            core.setOutput('should_retry', (transientErrors > 0 && failurePatterns.length <= 3) ? 'true' : 'false');
            core.setOutput('failed_count', failurePatterns.length);
            
            return analysis;

      - name: Retry Transient Failures
        if: steps.analyze.outputs.should_retry == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const run_id = context.payload.workflow_run.id;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            
            // Check recent retry attempts
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              per_page: 10
            });
            
            const recentRetries = runs.workflow_runs.filter(run => 
              run.head_sha === context.payload.workflow_run.head_sha &&
              run.run_attempt > 1
            );
            
            // Limit retries to 3 attempts
            if (recentRetries.length < 3) {
              console.log('Retrying failed workflow...');
              try {
                await github.rest.actions.rerunFailedJobs({
                  owner,
                  repo,
                  run_id
                });
                console.log('âœ… Retry initiated successfully');
              } catch (error) {
                console.log('âŒ Failed to retry:', error.message);
              }
            } else {
              console.log('âš ï¸  Maximum retry attempts reached (3)');
            }

      - name: Create Issue for Persistent Failures
        if: steps.analyze.outputs.failed_count > 0
        uses: actions/github-script@v7
        with:
          script: |
            const analysis = JSON.parse('${{ steps.analyze.outputs.analysis }}');
            const run_id = context.payload.workflow_run.id;
            const run_url = context.payload.workflow_run.html_url;
            
            // Check for existing issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['ci-failure', 'automated']
            });
            
            // Check if we've already created an issue for this commit
            const existingIssue = issues.find(issue => 
              issue.body && issue.body.includes(context.payload.workflow_run.head_sha)
            );
            
            if (!existingIssue && analysis.total_failed > 2) {
              let failureList = analysis.patterns.map(p => 
                `- **${p.job}**: [View Logs](${p.url})`
              ).join('\n');
              
              const title = `ðŸ”´ Persistent CI Failures Detected`;
              const body = `## CI Failure Alert
              
              Multiple CI jobs have failed for commit ${context.payload.workflow_run.head_sha.substring(0, 7)}.
              
              **Workflow Run:** ${run_url}
              **Branch:** ${context.payload.workflow_run.head_branch}
              **Failed Jobs:** ${analysis.total_failed}
              
              ### Failed Jobs
              ${failureList}
              
              ### Recommended Actions
              1. Review the failure logs linked above
              2. Check for common patterns (import errors, database connection issues)
              3. Run the pre-flight health check locally
              4. Fix identified issues and push changes
              
              **Auto-generated by Workflow Failure Recovery**
              *This issue will be automatically closed when the workflow passes.*`;
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['ci-failure', 'automated', 'bug']
              });
            }

      - name: Send Notification
        if: steps.analyze.outputs.failed_count > 5
        run: |
          echo "## ðŸš¨ Critical CI Failure" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Jobs:** ${{ steps.analyze.outputs.failed_count }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run:** ${{ github.event.workflow_run.html_url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Multiple jobs have failed. This may indicate a systemic issue." >> $GITHUB_STEP_SUMMARY
          echo "Please review the failure patterns and address the root cause." >> $GITHUB_STEP_SUMMARY

  close-resolved-issues:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Close Resolved Issues
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['ci-failure', 'automated']
            });
            
            for (const issue of issues) {
              if (issue.body && issue.body.includes(context.payload.workflow_run.head_sha)) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'âœ… CI workflow is now passing. Closing this issue automatically.'
                });
              }
            }
